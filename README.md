# magnets

A dynamic golang web application for e-commerce

Hugo is used to generate the html templates and page resources for the web application.

**The escaped functions (which need to appear in the final template files generated by hugo) are defined in [config.toml](/config.toml)**

The process for using hugo to generate templates for golang applications in this way __is not well documented elsewhere__. The advantage, of course, is avoiding having to manually edit any of the generated templates to insert the functions used by the web application.

In other words, this is a way to use (hugo)[gohugo.io] with a database.

The database used is [cockroachdb](https://www.cockroachlabs.com/docs/v20.2/build-a-go-app-with-cockroachdb-upperdb), with [upper/db](https://tour.upper.io/queries/01) as the database access layer.

Tested on Archlinux

## Prerequisite

```
yay -S cockroachdb go hugo
```
it's recommended to use `cockroachdb-bin` for faster testing and deployment

## CockroachDB Single Node

The first step is creating the certs used to establish the connection between the go application ([main.go](/main.go)) and cocroachdb. `make single-node` starts the cockroachdb node

in a terminal:
```
make clean0 certs0 single-node
```

A cockroach node is started. Proceed to [database setup](#database-setup)

## CockroachDB Cluster Setup

Nodes act as access points to the database. Nodes can be started as-needed to give an access point (in this example) within the local network to the database. **Follow along with the [upstream documentation of this process](https://www.cockroachlabs.com/docs/stable/deploy-cockroachdb-on-premises.html). You will need to sync the clocks first!**

**(note - you will need to change the example addresses and aliases in the Makefile for your cluster)**

```
make certs
```

The certificates are generated, and compressed into an archive. These must be copied to the corresponding node before continuing. Refer to the linked documentation above for a description of this process.

In this example, it is assume that this repository is cloned to the GOPATH on the nodes, and that, for instance, `certs1.tar.gz` is extracted into the cloned repository folder and is renamed `certs` from `certs1`.

## Starting the CockroachDB cluster

on each node, beginning with the primary instance
```
make start1
```

the local instance
```
make start0
```

the third node
```
make start2
```

the fourth node
```
make start3
```
refer to the documentation in cockroachdb forr troubleshooting. This section is retained for internal reference.

## Database Setup

in a new terminal or tab:
```
make db-secure
```

## Sync Dependencies

Sync the needed golang dependencies
```
go mod init
go mod vendor -v
```

##Build the Frontend with Hugo

The hugo template exists and should be modified or customized if desired. A modification to the hugo.386 theme is employed here.

As previously mentioned, hugo is generating a __template__ for the golang web application.

Any hugo theme can be used, view the functions which are included in the final template as a reference point to the default database format.

Build the front end (or rebuild after changing)
```
hugo -D
```

Live-editing the hugo templates is also possible, this is done independent of the golang web application.

```
hugo server -D
```

## Run the application
test the database connection and view the help menu with no flags:
```
go run main.go
```
output:
```
$ go run main.go
Initializing cockroachDB connection
Usage: magnets -dDctCyepirh
	Suggested Demo: magnets -ctpr
  -y, --create100             Create 100 parts with sequential part numbers
  -C, --createpartno string   Create a part by providing the part number
  -c, --createtables          Create the tables if they do not exist
  -D, --deleteall             Delete the products in the products database
  -d, --droptables            Drop tables
  -e, --exportcsv             Export a csv to export01.csv
  -h, --help                  show this help menu
  -i, --importcsv             Import csv from http://127.0.0.1:8079/export01.csv
  -p, --printinventory        Print the inventory to the terminal
  -r, --run                   run the web app
  -t, --testprod              create test product
  -v, --vprintinventory       More verbose printinventory

```

Please note this is the order the flags are executed: -dDctCyepirh

Try the demo:
```
magnets -ctpr
```
* the product table is created in the products database
* test products are created
* the inventory is printed to the screen
* the web application is started (on 127.0.0.1:8040/)

## Managing Inventory

Inventory is managed through importing and exporting csv files. Let us first create a list of blank products, with only the ID and part number

```
go run main.go -y
```

The current limitation is that the inventory can be imported only into the existing __empty__ table. So the table must be cleared first before the csv can be imported. The following example demonstrates this workflow:

```
go run main.go -e
```
The inventory is exported (this is a lazy call directly to the Makefile; `make export`)

Open the CSV, and **be certain to format the first column as text**

Add some values. Make a folder called test
```
mkdir test
```
**Save the file into the directory created above with it's existing name**
Switch to that directory and start a http server
```
cd test
darkhttpd . --port 8079
```

Then, execute the import: (by first removing the existing products as indicated earlier)
```
go run main.go -Di
```

You may get a error message. You may get an error `slow query` which actually masks other errors as multiple errors are not printed. Rerun the transaction until either there is no error or until it is determined that there is error in the input.

## Production

requires caddy

```
yay -S caddy
```

reverse proxy to port 80 from 8040

```
sudo caddy reverse-proxy --from magnetosphere.net --to localhost:8040
```
